<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS Documentation</title>
  </head>
  <body>
    <nav id="navbar">
      <header>
        <h1>JS Documentation</h1>
      </header>
      <a href="#fundamentals" class="nav-link">Fundamentals</a>
      <a href="#advanced" class="nav-link">Advanced</a>
      <a href="#web_apis" class="nav-link">Web APIs</a>
      <a href="#tooling_&_misc" class="nav-link">Tooling & Misc</a>
      <a href="#next_steps" class="nav-link">Next Steps</a>
    </nav>
    <main id="main-doc">
      <!-- JS fundamentals  -->
      <section id="fundamentals" class="main-section">
        <header>Fundamentals</header>
        <p>
          The script tag always goes before closing the body tag in the HTML
          file.
        </p>
        <p>
          <span>Scope: </span>Defines where variables and functions are
          accesible inside of your program.
        </p>
        <h2>Global Scope</h2>
        <code> var fruit = 'apple'; console.log(fruit); </code>
        <h2>Local Scope</h2>
        <p>
          <span>Function scope: </span><strong>var</strong> defines function
          scope within the function. It cannot be accessed outside from it.
        </p>
        <code> function getDate(){ var date = new Date(); return date; } </code>
        <p>
          <span>Block scope: </span><strong>const</strong> and
          <strong>let</strong> define block scope. Is the area within if,
          switch, loops and whenever you see {curly brackets}, these variables
          exist only within the block.
        </p>
        <p>
          <span>Lexical scope: </span> Children scope have access to the parent
          scope
        </p>
        <code>
          function foo1(){ var fruit1 = 'apple'; const fruit2 = 'banana'; let
          fruit3 = 'strawberry'; function foo2(){ console.log(`Fruits are:
          ${fruit1}, ${fruit2} and ${fruit3}`); } foo2();} foo1();
        </code>
        <p>
          <span>Hoisting: </span>JS mechanism where variables and function
          declarations are moved to the top of their scope before code
          execution.
        </p>
        <h2>Const vs. let vs. var:</h2>
        <table>
          <tbody>
            <tr>
              <td></td>
              <td>var</td>
              <td>let</td>
              <td>const</td>
            </tr>
            <tr>
              <td>reassigned</td>
              <td>yes</td>
              <td>yes</td>
              <td>no</td>
            </tr>
            <tr>
              <td>scope</td>
              <td>function</td>
              <td>block</td>
              <td>block</td>
            </tr>
            <tr>
              <td>reference before declaration</td>
              <td>yes</td>
              <td>no</td>
              <td>no</td>
            </tr>
          </tbody>
        </table>
        <p>
          <span>Const: </span> Used when you don't want to reassign the
          variable. It stays constant once it's declared.
        </p>
        <p>
          <span>Let: </span> After ES6 "let" is more welcome than "var". This is
          because let is in block scope which means it only exists within its
          own scope.
        </p>
        <p>
          <span>Var: </span> Old way to declare variable in JS and now the
          weakest keyword to define a variable. It may or may not be reassigned
          or be used for entire function.
        </p>
        <h2>Data Types</h2>
        <ul>
          <li>undefined -> // var x;</li>
          <li>boolean -> // var x = true;</li>
          <li>number -> // var x = 5;</li>
          <li>string -> // var x = 'hello';</li>
          <li>bigint -> // const x = 123456789n</li>
          <li>symbol -> // const x = Symbol();</li>
          <li>null -> // var x = null;</li>
          <li>object -> // let x = Object();</li>
          <li>function -> // const x = function(){}</li>
        </ul>
        <h2>Data Structures</h2>
        <img src="https://i.stack.imgur.com/UIwm1.png" alt="array-img" />
        <p>
          <span>Array: </span> Stores data in memory for later use. Each array
          has a fixed number of cells decided on its creation, and each cell has
          a corresponding numeric index used to select its data.
        </p>
        <table>
          <tbody>
            <tr>
              <td>Advantages</td>
              <td>Disadvantages</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Simple to create and use</li>
                  <li>
                    Foundational building block for complex data structure
                  </li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>Fixed size</li>
                  <li>Expensive to insert/delete or resequence values</li>
                  <li>Inefficient to sort</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Applications</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Basic spreadsheets</li>
                  <li>Within complex structures such as hash tables</li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
        <img
          src="https://www.studytonight.com/code/python/ds/images/queue-basic.png"
          alt="queue-img"
        />
        <p>
          <span>Queues: </span> Old way to declare variable in JS and now the
          weakest keyword to define a variable. It may or may not be reassigned
          or be used for entire function.
        </p>
        <table>
          <tbody>
            <tr>
              <td>Advantages</td>
              <td>Disadvantages</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Dynamic size</li>
                  <li>Orders data in the order it was received</li>
                  <li>Low runtime</li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>Can only retrieve the oldest element</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Applications</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Effective as a buffer when receiving frequent data</li>
                  <li>
                    Convenient way to store order-sensitive data such as stored
                    voicemails
                  </li>
                  <li>Ensures the oldest data is processed first</li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
        <img
          src="https://courses.cs.vt.edu/csonline/DataStructures/Lessons/OrderedListImplementationView/linked_list.gif"
          alt="linkedlist-img"
        />
        <p>
          <span>Linked list: </span> It doesn't use physical placement of data
          in memory. It uses a referencing system, elements are stored in nodes
          that contain a pointer to the next node, repeating until all nodes are
          linked. It allows efficient insertion and removal of items without the
          need for reorganization.
        </p>
        <table>
          <tbody>
            <tr>
              <td>Advantages</td>
              <td>Disadvantages</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Efficient insertion and removal of new elements</li>
                  <li>Less complex than restructuring an array</li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>Uses more memory than arrays</li>
                  <li>Inefficient to retrieve a specific element</li>
                  <li>Inefficient to traverse the list backwards</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Applications</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>
                    Best used when data must be added and removen in quick
                    succession from unknown locations
                  </li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
        <img
          src="https://miro.medium.com/max/303/1*wAsNx2NFmGE6OcG2Obl-8Q.jpeg"
          alt="trees-img"
        />
        <p>
          <span>Trees: </span> Specialize in representing hierarchical
          structures. Like a linked list, nodes contain both elements of data
          and pointers marking its relation to immediate nodes. Each tree has a
          "root" node. It contains references to all elements below it, which
          are known as its "child nodes". Each one branches off into more child
          nodes. E.g. Binary search trees
        </p>
        <table>
          <tbody>
            <tr>
              <td>Advantages</td>
              <td>Disadvantages</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Ideal for storing hierarchical relationships</li>
                  <li>Dynamic size</li>
                  <li>Quick at insert and delete operations</li>
                  <li>
                    In a binary search tree, inserted nodes are sequenced
                    immediately
                  </li>
                  <li>
                    Binary search trees are efficient at searches, length is
                    only O (height)
                  </li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>Slow to rearrange nodes</li>
                  <li>
                    Child nodes hold no information about their parent node
                  </li>
                  <li>Binary search trees are not as fast as hash tables</li>
                  <li>
                    Binary search trees can degenerate into linear search
                    (scanning all elements) if not implemented with balanced
                    subtrees
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Applications</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Storing hierarchical data such as a file location</li>
                  <li>
                    Binary search trees are excellent for tasks needing
                    searching or ordering of data
                  </li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
        <img
          src="https://courses.cs.vt.edu/csonline/DataStructures/Lessons/Graphs/graph.gif"
          alt="graphs-img"
        />
        <p>
          <span>Graphs: </span> Relation-based data structure helpful for
          storing web-like relationships. Each node, or vertex, as they're
          called in graphs, has a title (A,B,C,D,etc.), a value contained
          within, and a list of links (called edges) it has with other vertices.
          V = {a,b,c,d} ; E = {ab, ac, bc, cd}.
        </p>
        <table>
          <tbody>
            <tr>
              <td>Advantages</td>
              <td>Disadvantages</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Can quickly convey visuals over text</li>
                  <li>
                    Usable to model a diverse number of subjects so long as they
                    contain a relational structure
                  </li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>
                    At a higher level, text can be time-consuming to convert to
                    an image
                  </li>
                  <li>
                    It can be dificult to see the existing edges or how many
                    edges a given vertex has connected to it
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Applications</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Network representations</li>
                  <li>Modeling social networks, such as Facebook</li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
        <img
          src="https://www.w3schools.in/wp-content/uploads/2016/09/Data-Structures-Algorithms-Stack.png"
          alt="stacks-img"
        />
        <p>
          <span>Stacks: </span> The main operations are the addition of an item,
          known as push, and removal of it, known as pop. Stacks implement a
          LIFO structure.
        </p>
        <img
          src="https://buzzle.com/images/diagrams/hash-table-data-structure.jpg"
          alt="hashtable-img"
        />
        <p>
          <span>Hash Tables (Map): </span> Complex data structure capable of
          storing large amounts of information and retrieving specific elements
          efficiently. It relies on the concept of key/value pairs, where the
          "key" is a searched string and the "value" is the data paired with
          that key. Each searched key is converted from string to a numerical
          value called "hash", using a predefined hash function. This hash then
          points to a storage bucket. It then searches the bucket for the
          originally entered key and returns the values associated with that
          key.
        </p>
        <table>
          <tbody>
            <tr>
              <td>Advantages</td>
              <td>Disadvantages</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>
                    Key can be in any form while array's indices must be
                    integers
                  </li>
                  <li>Highly efficient search function</li>
                  <li>Constant number of operations for each search</li>
                  <li>Constant cost for insertion or deletion operations</li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>
                    Collisions: an error caused when 2 keys convert to the same
                    hash code or 2 hash codes point to the same value
                  </li>
                  <li>
                    These errors can be common and often require an overhaul of
                    the hash function
                  </li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>Applications</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>Database storage</li>
                  <li>Address lookups by name</li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
        <h2>JS type conversions</h2>
        <table>
          <tbody>
            <tr>
              <td>Implicit</td>
              <td>Explicit</td>
            </tr>
            <tr>
              <td>
                <ul>
                  <li>to string -> // '3' + true</li>
                  <li>to number -> // '2' - '2'</li>
                  <li>to NaN -> // 'hello' - 'world'</li>
                  <li>Boolean to number -> // 4 + false</li>
                  <li>null to number -> // 4 + null</li>
                  <li>
                    undefined with num, bool, null -> // 4 + undefined => NaN
                  </li>
                </ul>
              </td>
              <td>
                <ul>
                  <li>to number -> // result = Number('324');</li>
                  <li>to string -> // result = String(324);</li>
                  <li>to boolean -> // result = Boolean(0);</li>
                </ul>
              </td>
            </tr>
          </tbody>
        </table>
        <h2>= vs. == vs. ===</h2>
        <table>
          <tbody>
            <tr>
              <td>Operator</td>
              <td>What is?</td>
              <td>Why using it?</td>
            </tr>
            <tr>
              <td>'='</td>
              <td>
                Equal to (=) is an assignment operator which sets the variable
                on the left of the = to the value of the expression that is on
                its right.
              </td>
              <td>Assigns values to a variable.</td>
            </tr>
            <tr>
              <td>'=='</td>
              <td>
                Double equals (==) is a comparison operator, which transforms
                the operands having the same type before comparisonl
              </td>
              <td>
                compare the identity of two operands eventhough, they are not of
                a similar type.
              </td>
            </tr>
            <tr>
              <td>'==='</td>
              <td>
                Triple equals (===) is a strict equality comparison operator,
                which returns false for the values which are not of a similar
                type.
              </td>
              <td>Check that two values are the same or not.</td>
            </tr>
          </tbody>
        </table>
        <h2>Loops</h2>
        <p>
          <span>For: </span> This statement is a type of loop that will use up
          to three optional expressions to implement the repeated execution of a
          code block. It is good for working with arrays.
        </p>
        <code> for(let i=0; i'<'4; i++){ } </code>
        <p>
          <span>For...in: </span> This statement iterates over the properties of
          an object.
        </p>
        <code>
          const shark = { species: 'great white', collor: 'white',
          numberOfTeeth: Infinity }
        </code>
        <code>
          for(attribute in shark){ console.log(`${attribute}`.toUpperCase() + `:
          ${shark[attribute]}`); }
        </code>
        <code>
          Output // SPECIES: great white COLOR: white NUMBEROFTEETH: Infinity
        </code>
        <p>
          <span>For...of: </span> This statement is useful for iterating over
          iterable objects like arrays and strings. It is a new feature as of
          ES6. It is good for iterating arrays and strings in the ES6 way.
        </p>
        <code>
          for(let[index,shark] of sharks.entries()){ console.log(index,shark); }
        </code>
        <p>
          <span>While: </span> In this statement the condition is tested at the
          beginning of the loop. If condition is true, statements inside the
          loop will execute.
        </p>
        <code> let x=7; while(x>7){ // Do something } </code>
        <p>
          <span>Do...while: </span> In this statement the condition is tested at
          the end of the loop. It executes the statements in the code block at
          least once even if the condition fails.
        </p>
        <code> let y=7; do {console.log(y);} while(y>7); </code>
        <p>
          <span>Break: </span> It is a statement that can be used to jump out of
          a loop.
        </p>
        <code> for(let i=0; i'<'10; i++){ if(i===3){break;}} </code>
        <p>
          <span>Continue: </span> This statement breaks one iteration (in the
          loop), if a specified condition occurs, and continues with the next
          iteration in the loop.
        </p>
        <h2>Conditional statements</h2>
        <p>
          <span>If: </span> Specifies a block of code to be executed, if a
          specified condition is <strong>true</strong>
        </p>
        <p>
          <span>Else: </span> Specifies a block of code to be executed, if the
          same condition is <strong>false</strong>
        </p>
        <p>
          <span>Else if: </span> Specifies a new condition to tes, if the first
          condition is <strong>false</strong>
        </p>
        <code>
          if(grade>=90){ // print something; } else if(grade '<' 90 && grade >=
          60){ // Print other message; } else { // Print last message; }
        </code>
        <p>
          <span>Switch: </span> This statement is used to perform different
          actions based on different conditions.
        </p>
        <code>
          switch(x){ case 0: // do something; break; case 1: // do something;
          break; default: // do something; // It does not need a break because
          it is the last statement }
        </code>
        <h2>Errors</h2>
        <p><span>Try: </span> Lets you test a block of code for errors.</p>
        <p><span>Catch: </span> Lets you handle the error</p>
        <p><span>Throw: </span> Lets you create custom errors.</p>
        <p>
          <span>Finally: </span> Lets you execute code, after try and catch,
          regardless of the result.
        </p>
        <code>
          try { // Block of code to try; // if(something) throw "error message";
          } catch(err) { // Block of code to handle errors; } finally { // Block
          of code to be executed regardless of the try/catch result; }
        </code>
        <h2>Expressions & Operators</h2>
        <h3>Assignment Operators</h3>
        <table>
          <tbody>
            <tr>
              <td>Name</td>
              <td>Shorthand Operator</td>
              <td>Meaning</td>
            </tr>
            <tr>
              <td>Equal</td>
              <td>a = b</td>
              <td>a = b</td>
            </tr>
            <tr>
              <td>Addition Assignment</td>
              <td>a += b</td>
              <td>a = a + b</td>
            </tr>
            <tr>
              <td>Subtraction Assignment</td>
              <td>a -= b</td>
              <td>a = a - b</td>
            </tr>
            <tr>
              <td>Multiplication Assignment</td>
              <td>a *= b</td>
              <td>a = a * b</td>
            </tr>
            <tr>
              <td>Division Assignment</td>
              <td>a /= b</td>
              <td>a = a / b</td>
            </tr>
            <tr>
              <td>Remainder Assignment</td>
              <td>a %= b</td>
              <td>a = a % b</td>
            </tr>
            <tr>
              <td>Exponentiation Assignment</td>
              <td>a **= b</td>
              <td>a = a ** b</td>
            </tr>
            <tr>
              <td>Left Shift Assignment</td>
              <td>a <<= b</td>
              <td>a = a << b</td>
            </tr>
            <tr>
              <td>Right Shift Assignment</td>
              <td>a >>= b</td>
              <td>a = a >> b</td>
            </tr>
            <tr>
              <td>Bitwise AND Assignment</td>
              <td>a &= b</td>
              <td>a = a & b</td>
            </tr>
            <tr>
              <td>Bitwise OR Assignment</td>
              <td>a |= b</td>
              <td>a = a | b</td>
            </tr>
            <tr>
              <td>Bitwise XOR Assignment</td>
              <td>a ^= b</td>
              <td>a = a ^ b</td>
            </tr>
          </tbody>
        </table>
        <h3>Arithmetic Operators</h3>
        <table>
          <tbody>
            <tr>
              <td>Name</td>
              <td>Syntax</td>
            </tr>
            <tr>
              <td>Addition (+)</td>
              <td>a + b</td>
            </tr>
            <tr>
              <td>Concatenation (+)</td>
              <td>a + 'hello'</td>
            </tr>
            <tr>
              <td>Subtraction (-)</td>
              <td>a - b</td>
            </tr>
            <tr>
              <td>Multiplication (*)</td>
              <td>a * b</td>
            </tr>
            <tr>
              <td>Division (/)</td>
              <td>a / b</td>
            </tr>
            <tr>
              <td>Modulus (%)</td>
              <td>a % b</td>
            </tr>
            <tr>
              <td>Exponentiation (**)</td>
              <td>a ** b</td>
            </tr>
            <tr>
              <td>Increment (++)</td>
              <td>a++ / ++a</td>
            </tr>
            <tr>
              <td>Decrement (--)</td>
              <td>a-- / --a</td>
            </tr>
            <tr>
              <td>Unary (-)</td>
              <td>-a</td>
            </tr>
            <tr>
              <td>Unary (+)</td>
              <td>+a</td>
            </tr>
          </tbody>
        </table>
        <h3>Logical Operators</h3>
        <table>
          <tbody>
            <tr>
              <td>Name</td>
              <td>Operator</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>OR</td>
              <td>||</td>
              <td>
                If any argument is true, returns true. Else, returns false.
              </td>
            </tr>
            <tr>
              <td>AND</td>
              <td>&&</td>
              <td>
                If both operands are truthy, returns true. Else, returns false.
              </td>
            </tr>
            <tr>
              <td>NOT</td>
              <td>!</td>
              <td>
                Converts the operand to boolean type and returns the inverse
                value.
              </td>
            </tr>
          </tbody>
        </table>
        <h3>Conditional (Ternary) Operator</h3>
        <h4>Simple</h4>
        <code> condition ? expressionIfTrue : expressionIfFalse </code>
        <p>It is equivalent to: if { } else { }</p>
        <h4>Chains</h4>
        <code> condition1 ? value1 : condition2 ? value2 : value3; </code>
        <p>It is equivalent to: if { } else if { } else { }</p>
        <h3>Comparison Operators</h3>
        <table>
          <tbody>
            <tr>
              <td>Operator</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>==</td>
              <td>Equal to</td>
            </tr>
            <tr>
              <td>===</td>
              <td>Equal value and type</td>
            </tr>
            <tr>
              <td>!=</td>
              <td>Not equal</td>
            </tr>
            <tr>
              <td>!==</td>
              <td>Not equal value or type</td>
            </tr>
            <tr>
              <td>></td>
              <td>Greater than</td>
            </tr>
            <tr>
              <td><</td>
              <td>Less than</td>
            </tr>
            <tr>
              <td>>=</td>
              <td>Greater than or equal to</td>
            </tr>
            <tr>
              <td><=</td>
              <td>Less than or equal to</td>
            </tr>
          </tbody>
        </table>
        <h3>Bitwise Operators</h3>
        <table>
          <tbody>
            <tr>
              <td>Operator</td>
              <td>Name</td>
              <td>Description</td>
            </tr>
            <tr>
              <td>&</td>
              <td>AND</td>
              <td>Sets each bit to 1 if both are 1</td>
            </tr>
            <tr>
              <td>|</td>
              <td>OR</td>
              <td>Sets each bit to 1 if 1/2 bits is 1</td>
            </tr>
            <tr>
              <td>^</td>
              <td>XOR</td>
              <td>Sets each bit to 1 if only 1/2 bits is 1</td>
            </tr>
            <tr>
              <td>~</td>
              <td>NOT</td>
              <td>Inverts all the bits</td>
            </tr>
            <tr>
              <td><<</td>
              <td>Zero fill left shift</td>
              <td>
                Shifts left by pushing 0s in from the right and let the leftmost
                bits fall off
              </td>
            </tr>
            <tr>
              <td>>></td>
              <td>Signed right shift</td>
              <td>
                Shifts right by pushing copies of the leftmost bit in from the
                left, and let the rightmost bits fall off
              </td>
            </tr>
            <tr>
              <td>>>></td>
              <td>Zero fill right shift</td>
              <td>
                Shifts right by pushing 0s in from the left, and let the
                rightmost bits fall off
              </td>
            </tr>
          </tbody>
        </table>
        <h3>Comma Operator (,)</h3>
        <p>
          It is used to execute two expressions sequentially. It evaluates each
          of its operands from left to right first and then value of the last
          operand will be reurned as the result.
        </p>
        <code> leftHandExpression, rightHandExpression </code>
        <h3>Unary Operators</h3>
        <table>
          <tbody>
            <tr>
              <td>Operator</td>
              <td>Name</td>
              <td>Explanation</td>
            </tr>
            <tr>
              <td>+</td>
              <td>Unary plus</td>
              <td>Tries to convert the operand into a number</td>
            </tr>
            <tr>
              <td>-</td>
              <td>Unary negation</td>
              <td>
                Tries to convert the operand into a number and negates after
              </td>
            </tr>
            <tr>
              <td>!</td>
              <td>Logical not</td>
              <td>Converts to boolean value and then negates it</td>
            </tr>
            <tr>
              <td>++</td>
              <td>Increment</td>
              <td>Adds one to its operand</td>
            </tr>
            <tr>
              <td>--</td>
              <td>Decrement</td>
              <td>Decrements by one from its operand</td>
            </tr>
            <tr>
              <td>~</td>
              <td>Bitwise not</td>
              <td>Inverts all the bits in the operand and returns a number</td>
            </tr>
            <tr>
              <td>none</td>
              <td>typeof</td>
              <td>Returns a string which is the type of the operand</td>
            </tr>
            <tr>
              <td>none</td>
              <td>delete</td>
              <td>
                Deletes specific index of an array or specific property of an
                object
              </td>
            </tr>
            <tr>
              <td>none</td>
              <td>void</td>
              <td>Discards a return value of an expression</td>
            </tr>
          </tbody>
        </table>
        <h3>Rest vs. Spread Operator (...)</h3>
        <p>
          <strong>Rest operator</strong> helps us to pass infinite number of
          function arguments.
        </p>
        <code>
          function sum(a, b, ...remaining){ console.log(a); console.log(b);
          console.log(remaining); } sum(1,2,3,4,5,6,7,8,9);
        </code>
        <p>
          <strong>Spread operator</strong> helps us to expand the strings or
          array/object literals.
        </p>
        <h4>1. Split strings</h4>
        <code>
          let x = 'Socrates'; let arrName = [...x]; console.log(arrName); //
          Output -> ['S','o','c','r','a','t','e','s']
        </code>
        <h4>2. Merge arrays</h4>
        <code>
          const arr1 = [1,2,3]; const arr2 = [4,5,6]; const mergedArr =
          [...arr1, ...arr2]; console.log(mergedArr); // Output -> [1,2,3,4,5,6]
        </code>
        <h4>3. Merge objects</h4>
        <code>
          const obj1 = {a:1, b:2} const obj2 = {c:3, d:4} const mergedObj =
          {...obj1, ...obj2}; console.log(mergedObj); // Output -> {a:1, b:2,
          c:3, d:4}
        </code>
        <h4>4. Using it in function calls</h4>
        <code>
          const nums = [1,2,3]; // function calling sum(...nums); // Output ->
          1+2+3 = 6
        </code>
        <h2>Functions</h2>
        <h3>Function Declarations (ES5)</h3>
        <code> function functionName(params) { // code to be executed } </code>
        <h3>Function Expressions</h3>
        <code>
          var x = function(a,b) {return a*b}; var z = x(2,4); // x is an
          anonymous function (without name)
        </code>
        <h3>Arrow Functions (ES6)</h3>
        <code> const x = (x,y) => {x*y}; </code>
        <h3>Regular functions vs. Arrow Functions</h3>
        <table>
          <tbody>
            <tr>
              <td>Regular Functions</td>
              <td>Arrow Functions</td>
            </tr>
            <tr>
              <td>Can use "this" keyword</td>
              <td>Are callable</td>
            </tr>
            <tr>
              <td>Can use "new" keyword (constructible)</td>
              <td>Less code</td>
            </tr>
          </tbody>
        </table>
        <h2>Array Methods</h2>
        <ul>
          <li>.toString() -> converts an array to a string</li>
          <li>.join() -> joins all array elements into a string</li>
          <li>.pop() -> removes the last element from an array</li>
          <li>.push() -> adds a new element to an array at the end</li>
          <li>.shift() -> removes the first array element</li>
          <li>
            .unshift() -> adds a new element to the array at the beginning
          </li>
          <li>.splice() -> can be used to add new items to an array</li>
          <li>.concat() -> creates a new array by merging existing arrays</li>
          <li>.slice() -> slices out a piece of an array into a new array</li>
          <li>.sort() -> sorts an array alphabetically</li>
          <li>.reverse() -> reverses the elements in an array</li>
          <li>.forEach() -> calls a function once for each array element</li>
          <li>
            .map() -> creates a new array by performing a function on each
            element
          </li>
          <li>
            .filter() -> creates a new array with array elements that passes a
            test
          </li>
          <li>
            .reduce() -> runs a function on each array element to reduce to a
            single value
          </li>
          <li>.reduceRight() -> same as .reduce()</li>
          <li>.every() -> ched if all array values pass a test</li>
          <li>.some() -> check if some array values pass a test</li>
          <li>
            .indexOf() -> searches an array for an element value and returns it
            position
          </li>
          <li>.lastIndexOf() -> same as .indexOf()</li>
          <li>
            .find() -> returns value of the first array element that passes a
            test function
          </li>
          <li>
            .findIndex() -> returns index of the first array element that passes
            a test function
          </li>
        </ul>
        <h2>Destructuring</h2>
        <p>
          Lets unpack values from arrays, or properties from objects, into
          distinct variables
        </p>
        <code> let a, b, rest; [a, b, ...rest] = [10, 20, 30, 40, 50]; </code>
      </section>
      <!-- JS advanced -->
      <section id="advanced" class="main-section">
        <header>Advanced</header>
        <p>
          <strong>Closure: </strong> Gives you access to an outer function's
          scope from an inner function.
        </p>
        <img
          src="http://www.jomendez.com/wp-content/uploads/2015/11/javascript-closure1.png"
          alt="closure-img"
        />
        <p>
          <strong>Currying: </strong> Advanced technique of working with
          functions. Transforms a function from callable as f(a,b,c) into
          callable as f(a)(b)(c). Currying does not call a function. It just
          transforms it.
        </p>
        <img
          src="https://miro.medium.com/max/2832/1*wRWT8kGbP5wxlGtrTcAALA.png"
          alt="currying-img"
        />
        <h2>"This" keyword</h2>
        <p>
          Refers to the object it belongs to. It has different values depending
          on where it is used:
        </p>
        <ul>
          <li>
            In a <strong>method</strong>, "this" refers to the owner object
          </li>
          <li><strong>Alone</strong>, "this" refers to the global object</li>
          <li>
            In a <strong>function</strong>, "this" refers to the global object
          </li>
          <li>
            In a function, in <strong>strict mode</strong>, "this" is undefined
          </li>
          <li>
            In an <strong>event</strong>, "this" refers to the element that
            received the event
          </li>
          <li>
            Methods like call(), and apply() can refer "this" to any object
          </li>
        </ul>
        <p>
          <strong>Implicit Binding: </strong> Check what's to the left of the
          dot (.) operator adjacent to a function at invocation time. This
          determines what "this" is binding to.
        </p>
        <p>
          <strong>Explicit Binding: </strong> Call a function with an object
          when the function is outside of the execution context of the object.
        </p>
        <ul>
          <li>
            <strong>call():</strong> The context with wich the function has to
            be called will be passed as a parameter to the call().
            <strong>This</strong> is determined by what has been passed to the
            call() method.
          </li>
          <li>
            <strong>apply():</strong> It is the same as call() but allows you to
            pass the arguments more conveniently. Ideal when you have multiple
            value arguments to pass.
          </li>
          <li>
            <strong>bind():</strong> Similar to call() but it returns a brand
            new function and we can invoke that instead.
          </li>
        </ul>
        <p>
          <strong>new Binding: </strong> Used to create an object from the
          constructor function. When a function is invoked with the new keyword,
          JS creates an internal "this" object within the function. The newly
          created "this" binds to the object being created using the "new"
          keyword.
        </p>
        <p>
          <strong>Global Object Binding: </strong> If "this" keyword is not
          resolved with any of the bindings, implicit, explicit or new, then it
          it bound to the window (global) object. Except in 'strict mode'.
        </p>
        <p>
          <strong>HTML Event Element Binding: </strong> In HTML event handlers,
          "this" keyword binds to the HTML elements that receive the event.
        </p>
        <h2>Prototype</h2>
        <p>
          <strong>Inheritance: </strong> All JS objects inherit properties and
          methods from a prototype. These inherit from Object.prototype.
        </p>
        <ul>
          <li>Date object inherits from Date.prototype</li>
          <li>Array object inherits from Array.prototype</li>
          <li>Person object inherits from Person.prototype</li>
        </ul>
        <h3>Add props and methods to object</h3>
        <code>
          function Person(first, last, age, eyecolor) { this.firstname = first;
          this.lastname = last; this.age = age; this.eyecolor = eyecolor; }
        </code>
        <p>Adding property</p>
        <code>Person.prototype.nationality = 'English';</code>
        <p>Adding method</p>
        <code
          >Person.prototype.name = function() { return this.firstname + ' ' +
          this.lastname; }
        </code>
        <h2>Class</h2>
        <code>
          class Car { constructor(name, year) { this.name = name; this.year =
          year; } }
        </code>
        <h3>The constructor method</h3>
        <ul>
          <li>It has to have the exact name "constructor"</li>
          <li>Executed automatically when a new object is created</li>
          <li>Used to initialize object properties</li>
        </ul>
        <h3>Class methods</h3>
        <code>
          class ClassName{ constructor(){...} method1(){...} method2(){...} }
        </code>
        <h2>Iterators</h2>
        <ul>
          <li>for...of cycle (accepts iterables)</li>
          <li>Spread operator [...iterable]</li>
          <li>Array destructuring -> const[first, ...rest] = []</li>
          <li>Array.from() -> Array.from(iterable[mapfunc])</li>
        </ul>
        <h2>Native iterable types</h2>
        <ul>
          <li>iterable array</li>
          <li>iterable string</li>
          <li>iterable Map -> overkey and value pairs</li>
          <li>iterable Set -> over its items</li>
        </ul>
        <h2>Generators</h2>
        <p>
          <strong>Generator function:</strong> Can return (yield) multiple
          values. It returns an object generator.
        </p>
        <code
          >function* generateSequence() { yield 1; yield 2; return 3; }
        </code>
        <p>
          <strong>.next():</strong> Runs execution until nearest yield<>
          statement. Then it pauses and returns yielded value to the outer code.
          It returns an object with 2 props (value: val, done: boolean).
        </p>
        <ul>
          <li>Generators are iterable (*[Symbol.iterator]())</li>
          <li>Generator composition (yield*)</li>
          <li>Generator.throw(err)</li>
        </ul>
        <h2>Event loop</h2>
        <p>JS is single threaded. Memory allocation.</p>
        <p>
          <strong>Heap memory:</strong> Data stored randomly and memory
          allocated.
        </p>
        <p>
          <strong>Stack memory:</strong> Memory allocated in stacks. Mainly used
          for functions.
        </p>
        <p>
          <strong>Function call stack:</strong> A function which keeps track of
          all other functions executed in runtime.
        </p>
        <p>
          <strong>Event loop:</strong> Something that pulls stuff out of the
          queue and places it onto the function execution stack whenever the
          function stack becomes empty.
        </p>
        <p>
          The event loop is the secret by which JS gives an illusion of being
          multithreaded even though it's single-threaded.
        </p>
        <img src="https://i.stack.imgur.com/BTm1H.png" alt="eventloop-img" />
        <h2>Immediately Invoked Function Expression - IIFE</h2>
        <code> (function() { //Write JS code here } )(); </code>
        <h3>Advantages:</h3>
        <ul>
          <li>Do not create unnecessary global variables and functions</li>
          <li>
            Functions and variables defined in IIFE do not conflict with other
            functions & variables even if they have the same name
          </li>
          <li>Organize JS code</li>
          <li>Make JS code maintainable</li>
        </ul>
        <h2>Asynchronous JS</h2>
        <p>
          <strong>setTimeOut():</strong> calls a function or evaluates an
          expression after a specified number of milliseconds. 1000 ms = 1
          second. Function is executed once. clearTimeOut() prevents the
          function from running.
        </p>
        <code>setTimeOut(function, milliseconds, param1, param2, ...)</code>
        <p>
          <strong>setInterval():</strong> calls a function or evaluates an
          expression at specified intervals (in milliseconds). This method will
          continue calling the function until clearInterval() is called or
          window is closed.
        </p>
        <code>setInterval(function, milliseconds, param1, param2, ...)</code>
        <p>
          <strong>callbacks:</strong> function passed as an argument to another
          function. This allows a function to call another function. A callback
          function can run after another function has finished.
        </p>
        <code>
          function myFunc1(some) { // some code } function myFunc2(par1, par2,
          myCallback) { // some code myCallback(); } myFunc2(5, 5, myFunc1);
        </code>
        <p>
          <strong>promises:</strong> Is a JS object that links code that can
          take some time (producing code) and code that must wait for the result
          (consuming code).
        </p>
        <h3>Promise Object Properties: (state / result)</h3>
        <ul>
          <li>Pending -> undefined</li>
          <li>Fulfilled -> a value</li>
          <li>Rejected -> an error object</li>
        </ul>
        <img
          src="https://appdividend.com/wp-content/uploads/2018/10/Getting-Started-With-Javascript-Promise.png"
          alt="promise-img"
        />
        <p><strong>Async:</strong> Makes a function return a promise</p>
        <p><strong>Await:</strong> Makes a function wait for a promise</p>
        <img
          src="https://image.slidesharecdn.com/asynchistory-170422024901/95/async-history-javascript-19-638.jpg"
          alt="asyncawait-img"
        />
        <li></li>
        <li></li>
        <p></p>
        <p></p>
      </section>
      <!-- Built-in browser APIs -->
      <section id="web_apis" class="main-section">
        <header>Web APIs</header>
        <p></p>
        <p></p>
        <code></code>
        <code></code>
        <code></code>
        <li></li>
        <li></li>
        <p></p>
        <p></p>
      </section>
      <!-- Tooling and miscellaneous -->
      <section id="tooling_&_misc" class="main-section">
        <header>Tooling & Misc</header>
        <p></p>
        <p></p>
        <code></code>
        <code></code>
        <code></code>
        <li></li>
        <li></li>
        <p></p>
        <p></p>
      </section>
      <!-- Where to go, next steps -->
      <section id="next_steps" class="main-section">
        <header>Next Steps</header>
        <p></p>
        <p></p>
        <code></code>
        <code></code>
        <code></code>
        <li></li>
        <li></li>
        <p></p>
        <p></p>
      </section>
    </main>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  </body>
</html>
